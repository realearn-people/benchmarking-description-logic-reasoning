


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AxiomFormatter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.example</a>
</div>

<h1>Coverage Summary for Class: AxiomFormatter (org.example)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AxiomFormatter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.7%
  </span>
  <span class="absValue">
    (5/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.6%
  </span>
  <span class="absValue">
    (17/35)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.example;
&nbsp;
&nbsp;import org.semanticweb.owlapi.model.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * AxiomFormatter provides dual-format output for OWL axioms:
&nbsp; * - Symbolic: A compact, human-readable representation (e.g., ∃hasPart.Tail)
&nbsp; * - Functional: OWL functional syntax (e.g., SubClassOf(:Cat ObjectSomeValuesFrom(:hasPart :Tail)))
&nbsp; *
&nbsp; * This is primarily used for DL benchmarks to test human and LLM understanding.
&nbsp; */
<b class="nc">&nbsp;public class AxiomFormatter {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Converts an OWLAxiom into both symbolic and functional formats.
&nbsp;     *
&nbsp;     * @param axiom the OWLAxiom to format
&nbsp;     * @return a map with keys &quot;symbolic&quot; and &quot;functional&quot;
&nbsp;     */
&nbsp;    public static Map&lt;String, String&gt; formatAxiom(OWLAxiom axiom) {
<b class="fc">&nbsp;        Map&lt;String, String&gt; formats = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // Custom symbolic format
<b class="fc">&nbsp;        formats.put(&quot;symbolic-format&quot;, toSymbolicString(axiom));</b>
&nbsp;
&nbsp;        // Functional (default OWL)
<b class="fc">&nbsp;        formats.put(&quot;OWL-format&quot;, axiom.toString());</b>
&nbsp;
<b class="fc">&nbsp;        return formats;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a symbolic (human-readable) string for supported axiom types.
&nbsp;     * Falls back to OWL functional syntax for unsupported types.
&nbsp;     *
&nbsp;     * @param axiom the axiom to convert
&nbsp;     * @return symbolic string representation
&nbsp;     */
&nbsp;    private static String toSymbolicString(OWLAxiom axiom) {
<b class="pc">&nbsp;        if (axiom instanceof OWLSubClassOfAxiom) {</b>
<b class="fc">&nbsp;            return formatSubClassOfAxiom((OWLSubClassOfAxiom) axiom);</b>
<b class="nc">&nbsp;        } else if (axiom instanceof OWLObjectPropertyAssertionAxiom) {</b>
<b class="nc">&nbsp;            return formatObjectPropertyAssertionAxiom((OWLObjectPropertyAssertionAxiom) axiom);</b>
<b class="nc">&nbsp;        } else if (axiom instanceof OWLClassAssertionAxiom) {</b>
<b class="nc">&nbsp;            return formatClassAssertionAxiom((OWLClassAssertionAxiom) axiom);</b>
&nbsp;        }
&nbsp;        // Extend for other axiom types as needed
<b class="nc">&nbsp;        return axiom.toString(); // Default to functional string</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Formats a subclass axiom (e.g., Cat ⊑ ∃hasPart.Tail).
&nbsp;     */
&nbsp;    //uses the extractName method to extract the class names and the formatClassExpression method to format the superclass
&nbsp;    private static String formatSubClassOfAxiom(OWLSubClassOfAxiom sca) {
<b class="fc">&nbsp;        String sub = extractName(sca.getSubClass());</b>
<b class="fc">&nbsp;        OWLClassExpression superExpr = sca.getSuperClass();</b>
<b class="fc">&nbsp;        String sup = formatClassExpression(superExpr);</b>
<b class="fc">&nbsp;        return sub + &quot; ⊑ &quot; + sup;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Formats a class assertion axiom (e.g., pizza1 : Pizza).
&nbsp;     */
&nbsp;    // extracts the individual and class name using extractName
&nbsp;    private static String formatClassAssertionAxiom(OWLClassAssertionAxiom axiom) {
<b class="nc">&nbsp;        String individual = extractName(axiom.getIndividual());</b>
<b class="nc">&nbsp;        String className = extractName(axiom.getClassExpression());</b>
<b class="nc">&nbsp;        return individual + &quot; : &quot; + className;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Formats an object property assertion (e.g., pizza1 hasTopping Mozzarella).
&nbsp;     */
&nbsp;    // extracts the subject, property, and object using extractName
&nbsp;    private static String formatObjectPropertyAssertionAxiom(OWLObjectPropertyAssertionAxiom axiom) {
<b class="nc">&nbsp;        String individual = extractName(axiom.getSubject());</b>
<b class="nc">&nbsp;        String property = extractName(axiom.getProperty());</b>
<b class="nc">&nbsp;        String object = extractName(axiom.getObject());</b>
<b class="nc">&nbsp;        return individual + &quot; &quot; + property + &quot; &quot; + object;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Formats an OWL class expression into symbolic form.
&nbsp;     * supports:
&nbsp;     * - Existential quantification: ∃property.Class
&nbsp;     *
&nbsp;     * For all other expressions (e.g. named class), returns the short name or fallback label.
&nbsp;     *
&nbsp;     * @param expr the OWLClassExpression to format
&nbsp;     * @return symbolic string representation of the class expression
&nbsp;     */
&nbsp;    // formats class expressions, such as existential quantification (∃property.class) or role inversions (property^-1)
&nbsp;    private static String formatClassExpression(OWLClassExpression expr) {
&nbsp;        // // Check for existential quantification: ∃R.C
<b class="fc">&nbsp;        if (expr instanceof OWLObjectSomeValuesFrom some) {</b>
<b class="fc">&nbsp;            String prop = extractName(some.getProperty()); // e.g., hasTopping</b>
<b class="fc">&nbsp;            String filler = extractName(some.getFiller()); // e.g., Mozzarella</b>
<b class="fc">&nbsp;            return &quot;∃&quot; + prop + &quot;.&quot; + filler;</b>
&nbsp;        }
&nbsp;
&nbsp;        // For named classes or unsupported expressions, return readable name or fallback
<b class="fc">&nbsp;        return extractName(expr);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extracts the local name of a class expression.
&nbsp;     * If the expression is anonymous, returns a placeholder.
&nbsp;     */
&nbsp;    // extracting human-readable names from various OWL objects
&nbsp;    private static String extractName(OWLClassExpression expr) {
<b class="pc">&nbsp;        if (!expr.isAnonymous()) return expr.asOWLClass().getIRI().getShortForm();</b>
<b class="nc">&nbsp;        return &quot;AnonymousClass&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extracts the local name of an object property expression.
&nbsp;     * If anonymous, returns a placeholder.
&nbsp;     */
&nbsp;    private static String extractName(OWLObjectPropertyExpression propExpr) {
<b class="pc">&nbsp;        if (!propExpr.isAnonymous()) return propExpr.asOWLObjectProperty().getIRI().getShortForm();</b>
<b class="nc">&nbsp;        return &quot;AnonymousProperty&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extracts the local name of an OWL individual.
&nbsp;     * If anonymous, returns a placeholder.
&nbsp;     */
&nbsp;    private static String extractName(OWLIndividual individual) {
<b class="nc">&nbsp;        if (individual instanceof OWLNamedIndividual namedInd) {</b>
<b class="nc">&nbsp;            return namedInd.getIRI().getShortForm();</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;AnonymousIndividual&quot;;  // If the individual is anonymous, provide a fallback name</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-08-06 15:16</div>
</div>
</body>
</html>
